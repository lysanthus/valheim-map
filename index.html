<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Valheim World Map</title>

  <!-- World Seed: 8yz7mzFzt7 -->
  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">

  <!-- Leaflet.draw plugin -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css">
  
  <link rel="stylesheet" href="https://unpkg.com/leaflet-minimap/dist/Control.MiniMap.min.css">

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .suggest-panel {
      position: absolute;
      top: 70px;
      left: 10px;
      width: 260px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 8px 10px;
      font-family: sans-serif;
      font-size: 12px;
      border-radius: 4px;
      z-index: 1000;
    }
    
    .suggest-panel label {
      display: block;
      margin-top: 4px;
      margin-bottom: 2px;
    }
    
    .suggest-panel input[type="text"],
    .suggest-panel input[type="number"],
    .suggest-panel select,
    .suggest-panel textarea {
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 4px;
      font-size: 12px;
    }
    
    .suggest-panel textarea {
      resize: vertical;
    }
    
    .suggest-panel-buttons {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      margin-top: 4px;
    }
    
    .suggest-panel button {
      flex: 1;
      padding: 3px 4px;
      font-size: 11px;
      cursor: pointer;
    }
    
    .suggest-panel .geo-label {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 4px;
      margin-bottom: 2px;
      color: #fff; /* ensure it’s visible against the dark panel */
    }
    
    .hidden {
      display: none;
    }
    
    .suggest-active {
      outline: 2px solid #ffd700;
    }

    .coords-panel {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 6px 10px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 4px;
      z-index: 1000;
    }

    .legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.9);
      padding: 8px 10px;
      font-family: sans-serif;
      font-size: 13px;
      border-radius: 4px;
      z-index: 1000;
    }
    
    .legend-dot {
      display: inline-block;
      width: 14px;     /* matches radius ~7-ish visually */
      height: 14px;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: middle;
      border: 2px solid;
    }

    .legend div {
      margin-bottom: 4px;
    }

    /* Always-visible labels for certain points */
    .map-label {
      font-family: sans-serif;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
      text-shadow: 0 0 3px #000, 0 0 6px #000;
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0 2px;
    }

    /* Remove pointer triangle on permanent tooltips */
    .leaflet-tooltip.map-label:before,
    .leaflet-tooltip.map-label:after {
      display: none;
    }

    /* Road labels (if you decide to use them later) */
    .road-label {
      font-family: sans-serif;
      font-size: 13px;
      font-weight: 700;
      color: #ffffff;
      text-shadow: 0 0 4px #000, 0 0 6px #000;
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0 2px;
    }

    /* Panel showing last exported GeoJSON */
    .export-panel {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 320px;
      max-height: 200px;
      background: rgba(255,255,255,0.95);
      border-radius: 4px;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 11px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .export-panel label {
      font-family: sans-serif;
      font-size: 11px;
      font-weight: 600;
    }

    .export-panel textarea {
      flex: 1;
      resize: none;
      width: 100%;
      box-sizing: border-box;
    }
    
    .leaflet-tooltip.map-label {
      opacity: 0;
      transition: opacity 0.15s ease-in-out;
    }
    
    .leaflet-tooltip.map-label.leaflet-tooltip-visible {
      opacity: 1;
    }
    
    .search-panel {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.9);
      padding: 4px 6px;
      border-radius: 4px;
      font-family: sans-serif;
      font-size: 12px;
      z-index: 1000;
      display: flex;
      gap: 4px;
      align-items: center;
    }
    
    .search-panel input {
      font-size: 12px;
      padding: 2px 4px;
    }
    
    .search-panel button {
      font-size: 12px;
      padding: 2px 6px;
      cursor: pointer;
    }
    
    .search-results {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.95);
      border-radius: 4px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
      font-family: sans-serif;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      min-width: 220px;
    }
    
    .search-result-item {
      padding: 4px 6px;
      cursor: pointer;
    }
    
    .search-result-item:hover {
      background: #eee;
    }
    
    /* Geographic area labels: a "flavor" of hidden labels */
    .leaflet-tooltip.map-label.hidden-label.area-label {
      font-size: 14px;           /* slightly larger */
      color: rgba(255, 255, 255, 0.60);
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.6);
      letter-spacing: 2px;       /* optional: more "region name" vibe */
      text-transform: uppercase; /* optional */
    }
    
    .leaflet-tooltip.map-label {
      white-space: pre-line;
    }
    
  </style>
</head>

<body>
  <div id="map"></div>
  <div id="coords" class="coords-panel">Click the map to get pixel coordinates…</div>
  <div class="legend">
  <strong>Legend</strong>

  <div>
    <input type="checkbox" id="toggle-bases" checked>
    <span class="legend-dot" style="background:#00cc00; border-color:#006600;"></span>
    Base
  </div>

  <div>
    <input type="checkbox" id="toggle-portals" checked>
    <span class="legend-dot" style="background:#800080; border-color:#400040;"></span>
    Portal
  </div>

  <div>
    <input type="checkbox" id="toggle-outposts" checked>
    <span class="legend-dot" style="background:#ffa500; border-color:#cc8400;"></span>
    Outpost
  </div>

  <div>
    <input type="checkbox" id="toggle-pois" checked>
    <span class="legend-dot" style="background:#0000ff; border-color:#000080;"></span>
    POI
  </div>
  
  <div>
    <input type="checkbox" id="toggle-roads" checked>
    <span style="font-size: 16px; margin-right: 6px;">—</span>
    Road
  </div>
</div>

  <div class="export-panel">
    <label for="exportText">Last drawn road (GeoJSON Feature)</label>
    <textarea id="exportText" rows="6" spellcheck="false"
      placeholder="Use the polyline tool in the toolbar to draw a road.&#10;The resulting GeoJSON snippet will appear here."></textarea>
  </div>
  
  <button id="toggleLabelsBtn"
          style="position:absolute; top:160px; right:10px; z-index:1000; padding:4px 8px; font-size:12px;">
    Show All Labels
  </button>
  
  <button id="suggestPoiBtn"
          style="position:absolute; top:190px; right:10px; z-index:1000;">
    + Suggest POI
  </button>
    
    <div id="suggestPanel" class="suggest-panel hidden">
      <div><strong>Suggest a POI</strong></div>
      <div style="margin-bottom:4px; font-size:11px;">
        Fill in details, then click on the map to place it.
      </div>
    
      <label for="poiName">Name</label>
      <input id="poiName" type="text" placeholder="e.g. Swamp Outpost">
    
      <label for="poiKind">Type</label>
      <select id="poiKind">
        <option value="base">Base</option>
        <option value="outpost">Outpost</option>
        <option value="portal">Portal</option>
        <option value="poi">Generic POI</option>
        <option value="hidden">Hidden label (no icon)</option>
      </select>
    
      <label for="poiNotes">Notes</label>
      <textarea id="poiNotes" rows="3" placeholder="e.g. small shack, iron farm, etc."></textarea>
      
      <!-- New: Geography checkbox + angle -->
      <div style="margin-top:4px;">
        <label class="geo-label">
          <input type="checkbox" id="poiIsGeo">
          <span>Geography label (area)</span>
        </label>
      
        <div id="geoAngleRow" style="display:none; margin-left:18px; margin-top:2px;">
          <label for="poiAngle" style="margin:0 0 2px 0;">Label rotation (degrees)</label>
          <input id="poiAngle" type="number" value="0" min="-180" max="180" step="5">
        </div>
      </div>
    
      <label for="poiJson">JSON snippet (use Discord bot /addpoi)</label>
      <textarea id="poiJson" rows="5" readonly
                placeholder="After you click the map, the JSON will appear here."></textarea>
    
      <div class="suggest-panel-buttons">
        <button type="button" id="clearPoiBtn">Clear</button>
        <button type="button" id="closePoiBtn">Close</button>
      </div>
    </div>
    
    <div class="search-panel">
      <input id="poiSearchInput" type="text" placeholder="Search POIs..." />
      <button id="poiSearchBtn" type="button">Go</button>
      <button id="poiSearchClearBtn" type="button">Clear</button>
    </div>
    <div id="poiSearchResults" class="search-results" style="display:none;"></div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/leaflet-minimap/dist/Control.MiniMap.min.js"></script>

  <script>
    // Search index of POIs
    const searchIndex = [];
  
    // Image size in pixels
    const IMG_WIDTH = 4096;
    const IMG_HEIGHT = 4096;

    // Create a Leaflet map using a simple CRS (no real-world projection)
    const map = L.map('map', {
      crs: L.CRS.Simple,
      minZoom: -2,
      maxZoom: 2
    });
    
    // Define the map bounds in "pixel coordinates": [y, x]
    const bounds = [[0, 0], [IMG_HEIGHT, IMG_WIDTH]];

    // Add the image overlay
    L.imageOverlay('map.png', bounds).addTo(map);

    // Center and zoom (you already picked a zoom level you like)
    map.setView([IMG_HEIGHT / 2, IMG_WIDTH / 2], 1); // adjust zoom as desired
    
    // --- MiniMap setup ---

    // Use a separate imageOverlay layer for the minimap
    const miniLayer = L.imageOverlay('map.png', bounds);
    
    const fixedMiniZoom = -5;  // whatever zoom you liked best
    
    const miniMap = new L.Control.MiniMap(miniLayer, {
      position: 'topleft',
      width: 150,
      height: 150,
    
      // Fixed zoom level for the minimap
      zoomLevelFixed: fixedMiniZoom,
    
      // Make the minimap use the same CRS and lock zoom,
      // and also prevent the minimap itself from being dragged/zoomed.
      mapOptions: {
        crs: L.CRS.Simple,
        minZoom: fixedMiniZoom,
        maxZoom: fixedMiniZoom,
        zoomControl: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        touchZoom: false,
        boxZoom: false,
        keyboard: false,
        dragging: false   // <-- key: minimap image no longer drags
      },
    
      // NOTE: no centerFixed here; we want the minimap to follow the main map
    
      aimingRectOptions: { weight: 1 },
      shadowRectOptions: { weight: 0, opacity: 0 },
      toggleDisplay: true
    });
    
    miniMap.addTo(map);

    // Layer groups for categories
    const baseLayer    = L.layerGroup().addTo(map);
    const portalLayer  = L.layerGroup().addTo(map);
    const outpostLayer = L.layerGroup().addTo(map);
    const roadLayer    = L.layerGroup().addTo(map);
    const otherLayer   = L.layerGroup().addTo(map);
    const hiddenLayer  = L.layerGroup().addTo(map); // always on (for label anchors)


    // --- Suggest POI UI wiring ---

    const suggestBtn   = document.getElementById('suggestPoiBtn');
    const suggestPanel = document.getElementById('suggestPanel');
    const poiNameInput = document.getElementById('poiName');
    const poiKindInput = document.getElementById('poiKind');
    const poiNotesInput = document.getElementById('poiNotes');
    const poiJsonOutput = document.getElementById('poiJson');
    const clearPoiBtn  = document.getElementById('clearPoiBtn');
    const closePoiBtn  = document.getElementById('closePoiBtn');
    const poiIsGeo       = document.getElementById('poiIsGeo');
    const poiAngleInput  = document.getElementById('poiAngle');
    const geoAngleRow    = document.getElementById('geoAngleRow');
    
    let suggestMode = false;
    
    function setSuggestMode(on) {
      suggestMode = on;
      if (on) {
        suggestPanel.classList.remove('hidden');
        suggestBtn.classList.add('suggest-active');
      } else {
        suggestPanel.classList.add('hidden');
        suggestBtn.classList.remove('suggest-active');
      }
    }
    
    // Show/hide angle field and optionally force type to 'hidden'
    if (poiIsGeo && geoAngleRow) {
      poiIsGeo.addEventListener('change', () => {
        if (poiIsGeo.checked) {
          geoAngleRow.style.display = 'block';

          // Optional: force type to 'hidden' so it behaves as a label-only anchor
          if (poiKindInput) {
            poiKindInput.value = 'hidden';
          }
        } else {
          geoAngleRow.style.display = 'none';
        }
      });
    }
    
    // Toggle button
    suggestBtn.addEventListener('click', () => {
      setSuggestMode(!suggestMode);
    });
    
    // Clear fields
    clearPoiBtn.addEventListener('click', () => {
      poiNameInput.value = '';
      poiNotesInput.value = '';
      poiJsonOutput.value = '';

      if (poiIsGeo) {
        poiIsGeo.checked = false;
      }
      if (geoAngleRow) {
        geoAngleRow.style.display = 'none';
      }
      if (poiAngleInput) {
        poiAngleInput.value = '0';
      }
    });
    
    // Close panel and exit suggest mode
    closePoiBtn.addEventListener('click', () => {
      setSuggestMode(false);
    });



    // -------------------------
    //  Feature styling
    // -------------------------

    function pointToLayer(feature, latlng) {
      const props = feature.properties || {};
      const name = props.name || "";
      const kind = props.kind;
      let radius = 6;
      let color = '#000';
      let fillColor = '#fff';
      let options;
    
      if (kind === 'base') {
        radius = 12;
        fillColor = '#00cc00';
        color = '#006600';
        options = { radius, weight: 2, color, fillColor, fillOpacity: 1 };
    
      } else if (kind === 'portal') {
        radius = 8;
        fillColor = '#800080';
        color = '#400040';
        options = { radius, weight: 2, color, fillColor, fillOpacity: 1 };
    
      } else if (kind === 'outpost') {
        radius = 9;
        fillColor = '#ffa500';
        color = '#cc8400';
        options = { radius, weight: 2, color, fillColor, fillOpacity: 1 };
    
      } else if (kind === 'hidden') {
          const labelType = props.labelType || ''; // "area" for region labels
          const labelAngle = typeof props.labelAngle === 'number' ? props.labelAngle : null;
        
          let tooltipClass = 'map-label hidden-label';
          if (labelType === 'area') {
            tooltipClass += ' area-label';
          }
          if (labelAngle !== null) {
            tooltipClass += ' angled-label'; // extra class for CSS
          }
        
          // Wrap the name in a span so we can rotate just the text, not the tooltip container
          const labelHtml = labelAngle !== null
            ? `<span class="label-inner" data-angle="${labelAngle}">${name}</span>`
            : name;
        
          const tooltip = L.tooltip({
            permanent: true,
            direction: 'center',
            className: tooltipClass
          })
            .setContent(labelHtml)
            .setLatLng(latlng)
            .addTo(map);
        
          // After it's added, apply the rotation from data-angle
          if (labelAngle !== null) {
            const el = tooltip.getElement();
            if (el) {
              const inner = el.querySelector('.label-inner');
              if (inner) {
                inner.style.display = 'inline-block';
                inner.style.transform = `rotate(${labelAngle}deg)`;
                inner.style.transformOrigin = '50% 50%';
              }
            }
          }
        
          hiddenLayer.addLayer(tooltip);
          return;
        } else {
        // generic POIs
        fillColor = '#0000ff';
        color = '#000080';
        options = { radius, weight: 2, color, fillColor, fillOpacity: 1 };
      }
    
      return L.circleMarker(latlng, options);
    }

    function style(feature) {
      const kind = feature.properties && feature.properties.kind;
      if (kind === 'road') {
        return {
          weight: 5
        };
      }
      return {};
    }

    function onEachFeature(feature, layer) {
      const props = feature.properties || {};
    
      // 1) Hidden label-only points: always visible label, no popup
      if (props.kind === 'hidden' && props.name) {
        layer.bindTooltip(props.name, {
          permanent: true,
          direction: 'right',
          offset: [8, 0],
          className: 'map-label'
        }).openTooltip();
    
        // No popup for hidden points; bail out early
        return;
      }
    
      // 2) Everything else with a name: hover label
      if (props.name) {
        layer.bindTooltip(props.name, {
          permanent: false,      // show on hover
          direction: 'top',
          offset: [0, -8],
          className: 'map-label'
        });
      }
    
      // 3) Rich popup on click (name + notes)
      if (props.name || props.notes) {
        let popup = "";
    
        if (props.name) {
          popup += `<strong>${props.name}</strong>`;
        }
        if (props.notes) {
          if (popup) popup += "<br>";
          popup += props.notes;
        }
    
        if (popup) {
          layer.bindPopup(popup);
        }
      }
    
      // -----------------------------------------------------------
      // 4) HOVER HIGHLIGHT FOR ROADS
      // -----------------------------------------------------------
    
      if (props.kind === 'road') {
    
        // Save original styling so we can restore it later
        const originalStyle = Object.assign({}, layer.options);
    
        layer.on('mouseover', () => {
          layer.setStyle({
            ...originalStyle,
            weight: (originalStyle.weight || 3) * 1.8, // thicker
            opacity: 1,                                // fully visible
            color: '#ffffff'                           // bright highlight
          });
          layer.bringToFront();
        });
    
        layer.on('mouseout', () => {
          // Restore original style on mouse leave
          layer.setStyle(originalStyle);
        });
      }
    
    }

    // -------------------------
    //  Load existing features
    // -------------------------
    fetch('features.json')
      .then(response => response.json())
      .then(data => {
        L.geoJSON(data, {
          pointToLayer: pointToLayer,
          style: style,
          onEachFeature: function(feature, layer) {
            // keep your existing popup/label behavior
            onEachFeature(feature, layer);
    
            const props = feature.properties || {};
            const kind = props.kind || 'other';
    
            // Add to appropriate layer group
            let group;
            if (kind === 'base') {
              group = baseLayer;
            } else if (kind === 'portal') {
              group = portalLayer;
            } else if (kind === 'outpost') {
              group = outpostLayer;
            } else if (kind === 'road') {
              group = roadLayer;
            } else if (kind === 'hidden') {
              group = hiddenLayer;
            } else {
              group = otherLayer;
            }
            group.addLayer(layer);
    
            // Add to search index (skip hidden label anchors)
            if (props.name) {
              searchIndex.push({
                name: props.name,
                kind: kind,
                layer: layer
              });
            }
          }
        });
      })
      .catch(err => {
        console.error('Error loading features.json:', err);
      });

      // Category toggle checkboxes
      const cbBases    = document.getElementById('toggle-bases');
      const cbPortals  = document.getElementById('toggle-portals');
      const cbOutposts = document.getElementById('toggle-outposts');
      const cbPois     = document.getElementById('toggle-pois');
      const cbRoads    = document.getElementById('toggle-roads');
      
      if (cbBases) {
        cbBases.addEventListener('change', (e) => {
          if (e.target.checked) {
            map.addLayer(baseLayer);
          } else {
            map.removeLayer(baseLayer);
          }
        });
      }
      
      if (cbPortals) {
        cbPortals.addEventListener('change', (e) => {
          if (e.target.checked) {
            map.addLayer(portalLayer);
          } else {
            map.removeLayer(portalLayer);
          }
        });
      }
      
      if (cbOutposts) {
        cbOutposts.addEventListener('change', (e) => {
          if (e.target.checked) {
            map.addLayer(outpostLayer);
          } else {
            map.removeLayer(outpostLayer);
          }
        });
      }
      
      if (cbPois) {
        cbPois.addEventListener('change', (e) => {
          if (e.target.checked) {
            map.addLayer(otherLayer);
          } else {
            map.removeLayer(otherLayer);
          }
        });
      }
      
      if (cbRoads) {
        cbRoads.addEventListener('change', (e) => {
          if (e.target.checked) {
            map.addLayer(roadLayer);
          } else {
            map.removeLayer(roadLayer);
          }
        });
      }
      
    // --- POI search ---

    const searchInput   = document.getElementById('poiSearchInput');
    const searchBtn     = document.getElementById('poiSearchBtn');
    const searchResults = document.getElementById('poiSearchResults');
    const searchClearBtn = document.getElementById('poiSearchClearBtn');
    
    if (searchClearBtn) {
      searchClearBtn.addEventListener('click', () => {
        searchInput.value = '';
        searchResults.innerHTML = '';
        searchResults.style.display = 'none';
        searchInput.focus();
      });
    }

    function focusOnLayer(entry) {
      const layer = entry.layer;
    
      // For points: center and zoom in a bit
      if (layer.getLatLng) {
        const latlng = layer.getLatLng();
        const targetZoom = Math.max(map.getZoom(), 0); // don't zoom out when searching
        map.setView(latlng, targetZoom);
        if (layer.openPopup) {
          layer.openPopup();
        }
      }
      // For lines (roads): fit bounds
      else if (layer.getBounds) {
        const bounds = layer.getBounds();
        map.fitBounds(bounds);
      }
    }
    function updateAreaLabelSize() {
      const z = map.getZoom();
      const baseSize = 14;
      let scale = 1.0;
    
      // Hide area labels entirely at very low zoom
      const hideBelowZoom = 0;  // adjust to taste
    
      const areaLabels = document.querySelectorAll(
        '.leaflet-tooltip.map-label.hidden-label.area-label'
      );
    
      if (z <= hideBelowZoom) {
        areaLabels.forEach(el => {
          el.style.display = 'none';
        });
        return;
      } else {
        areaLabels.forEach(el => {
          el.style.display = '';
        });
      }
    
      // Scale size a bit (optional)
      if (z === 0)      scale = 0.8;
      else if (z === 1) scale = 0.95;
      else if (z === 2) scale = 1.0;
      else if (z >= 3)  scale = 1.1;
    
      const px = baseSize * scale;
      areaLabels.forEach(el => {
        el.style.fontSize = px + 'px';
      });
    }
    
    function performSearch() {
      const q = (searchInput.value || '').trim().toLowerCase();
      if (!q) {
        searchResults.style.display = 'none';
        searchResults.innerHTML = '';
        return;
      }
    
      const matches = searchIndex.filter(entry =>
        entry.name.toLowerCase().includes(q)
      );
    
      if (matches.length === 0) {
        searchResults.style.display = 'block';
        searchResults.innerHTML = '<div class="search-result-item">No matches</div>';
        return;
      }
    
      // Build results list (cap to first 20)
      searchResults.innerHTML = '';
      matches.slice(0, 20).forEach((entry, idx) => {
        const div = document.createElement('div');
        div.className = 'search-result-item';
        div.textContent = `${entry.name} [${entry.kind}]`;
        div.addEventListener('click', () => {
          searchResults.style.display = 'none';
          focusOnLayer(entry);
        });
        searchResults.appendChild(div);
      });
      searchResults.style.display = 'block';
    
      // Optionally, auto-focus the first result:
      // focusOnLayer(matches[0]);
    }
    
    // Button click
    if (searchBtn) {
      searchBtn.addEventListener('click', performSearch);
    }
    
    // Press Enter in input
    if (searchInput) {
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          performSearch();
        }
      });
    
      // Optional: live search while typing
      // searchInput.addEventListener('input', performSearch);
    }
    
    // Hide results when clicking on map
    map.on('click', () => {
      searchResults.style.display = 'none';
    });
    
    map.on('zoomend', updateAreaLabelSize);
      updateAreaLabelSize(); // run once on load

    // -------------------------
    //  Click to get pixel coordinates
    // -------------------------
    const coordsDiv = document.getElementById('coords');

    map.on('click', function(e) {
      const x = Math.round(e.latlng.lng);
      const y = Math.round(e.latlng.lat);
    
      coordsDiv.textContent = `x: ${x}, y: ${y}`;
    
      // If we're in Suggest POI mode, build a snippet for the player
      if (suggestMode) {
        const name  = poiNameInput.value.trim() || "New POI";
        let   kind  = (poiKindInput.value || "poi").trim();
        const notes = poiNotesInput.value.trim();

        const isGeo = poiIsGeo && poiIsGeo.checked;
        let angle   = null;

        if (poiAngleInput && poiAngleInput.value !== '') {
          const parsed = Number(poiAngleInput.value);
          if (!Number.isNaN(parsed)) {
            angle = parsed;
          }
        }

        // Build properties
        const props = {
          name:  name,
          kind:  kind,
          notes: notes
        };

        if (isGeo) {
          // Geography labels are a flavor of hidden labels
          props.labelType = 'area';

          // Force kind to hidden so it behaves like a label-only anchor on your map
          props.kind = 'hidden';

          if (angle !== null) {
            props.labelAngle = angle;   // this will be in the JSON for future rotation logic
          }
        }

        const feature = {
          type: "Feature",
          properties: props,
          geometry: {
            type: "Point",
            coordinates: [x, y]
          }
        };

        const jsonText = JSON.stringify(feature, null, 2);
        poiJsonOutput.value = jsonText;

        console.log('Suggested POI Feature:', jsonText);
        return;
      }
    
      // Normal behavior when NOT in suggest mode:
      const snippet = {
        type: "Feature",
        properties: {
          name: "New Place",
          kind: "base",
          notes: ""
        },
        geometry: {
          type: "Point",
          coordinates: [x, y]
        }
      };
      console.log('GeoJSON Point snippet:', JSON.stringify(snippet, null, 2));
    });

    // -------------------------
    //  Leaflet.draw setup
    // -------------------------
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
      draw: {
        polygon: false,
        rectangle: false,
        circle: false,
        circlemarker: false,
        marker: false,
        polyline: {
          shapeOptions: {
            weight: 3
          }
        }
      },
      edit: {
        featureGroup: drawnItems,
        edit: false,
        remove: false
      }
    });

    map.addControl(drawControl);

    const exportText = document.getElementById('exportText');

    // When a new shape is created with Leaflet.draw
    map.on(L.Draw.Event.CREATED, function (e) {
      const layer = e.layer;
      drawnItems.addLayer(layer);

      // Convert to GeoJSON
      const gj = layer.toGeoJSON();

      // gj.geometry.coordinates are [lng, lat] pairs in our CRS,
      // which map directly to [x, y] pixels. We'll round them.
      const coords = gj.geometry.coordinates.map(function (c) {
        return [Math.round(c[0]), Math.round(c[1])];
      });

      // Create a ready-to-paste Feature for features.json
      const feature = {
        type: "Feature",
        properties: {
          name: "New Road",
          kind: "road",
          notes: ""
        },
        geometry: {
          type: "LineString",
          coordinates: coords
        }
      };

      const snippet = JSON.stringify(feature, null, 2);

      console.log('New road Feature:', snippet);
      if (exportText) {
        exportText.value = snippet;
      }

      alert("Road drawn! A GeoJSON Feature for it is now in the bottom-right panel and in the browser console.\n\nCopy it into features.json under \"features\".");
    });
    
    // Always Visible Labels Toggle
    let labelsAlwaysVisible = false;

    document.getElementById('toggleLabelsBtn').addEventListener('click', () => {
      labelsAlwaysVisible = !labelsAlwaysVisible;
    
      // Update button text
      const btn = document.getElementById('toggleLabelsBtn');
      btn.textContent = labelsAlwaysVisible ? "Hide Labels" : "Show All Labels";
    
      // Function that toggles tooltip mode for a layer
      function toggleTooltip(layer) {
        if (!layer.getTooltip) return;      // not every layer has a tooltip
        const tt = layer.getTooltip();
        if (!tt) return;
    
        // Extract the existing content and class
        const content = tt._content;
        const className = tt.options.className || "";
    
        // Remove the old tooltip entirely
        layer.unbindTooltip();
    
        // Rebind with new visibility mode
        layer.bindTooltip(content, {
          permanent: labelsAlwaysVisible,
          direction: 'top',
          offset: [0, -10],
          opacity: 0.9,
          className: className
        });
    
        if (!labelsAlwaysVisible) {
          // In hover mode, ensure tooltip closes
          layer.closeTooltip();
        } else {
          layer.openTooltip();
        }
      }
    
      // Toggle all layer groups except hidden labels
      baseLayer.eachLayer(toggleTooltip);
      portalLayer.eachLayer(toggleTooltip);
      outpostLayer.eachLayer(toggleTooltip);
      otherLayer.eachLayer(toggleTooltip);
    
      // Roads rarely have tooltips but include them anyway
      roadLayer.eachLayer(toggleTooltip);
    
      // DO NOT toggle hidden label anchors — leave them always visible
    });
    
  </script>
</body>
</html>