<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Valheim World Map</title>

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">

  <!-- Leaflet.draw plugin -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css">
  
  <link rel="stylesheet" href="https://unpkg.com/leaflet-minimap/dist/Control.MiniMap.min.css">

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .coords-panel {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 6px 10px;
      font-family: monospace;
      font-size: 13px;
      border-radius: 4px;
      z-index: 1000;
    }

    .legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.9);
      padding: 8px 10px;
      font-family: sans-serif;
      font-size: 13px;
      border-radius: 4px;
      z-index: 1000;
    }
    
    .legend-dot {
      display: inline-block;
      width: 14px;     /* matches radius ~7-ish visually */
      height: 14px;
      border-radius: 50%;
      margin-right: 6px;
      vertical-align: middle;
      border: 2px solid;
    }

    .legend div {
      margin-bottom: 4px;
    }

    /* Always-visible labels for certain points */
    .map-label {
      font-family: sans-serif;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
      text-shadow: 0 0 3px #000, 0 0 6px #000;
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0 2px;
    }

    /* Remove pointer triangle on permanent tooltips */
    .leaflet-tooltip.map-label:before,
    .leaflet-tooltip.map-label:after {
      display: none;
    }

    /* Road labels (if you decide to use them later) */
    .road-label {
      font-family: sans-serif;
      font-size: 13px;
      font-weight: 700;
      color: #ffffff;
      text-shadow: 0 0 4px #000, 0 0 6px #000;
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0 2px;
    }

    /* Panel showing last exported GeoJSON */
    .export-panel {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 320px;
      max-height: 200px;
      background: rgba(255,255,255,0.95);
      border-radius: 4px;
      padding: 6px 8px;
      font-family: monospace;
      font-size: 11px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .export-panel label {
      font-family: sans-serif;
      font-size: 11px;
      font-weight: 600;
    }

    .export-panel textarea {
      flex: 1;
      resize: none;
      width: 100%;
      box-sizing: border-box;
    }
    
    .leaflet-tooltip.map-label {
      opacity: 0;
      transition: opacity 0.15s ease-in-out;
    }
    
    .leaflet-tooltip.map-label.leaflet-tooltip-visible {
      opacity: 1;
    }
    
  </style>
</head>

<body>
  <div id="map"></div>
  <div id="coords" class="coords-panel">Click the map to get pixel coordinates…</div>
  <div class="legend">
    <strong>Legend</strong>
    <div>
      <span class="legend-dot" style="background:#00cc00; border-color:#006600;"></span>
      Base
    </div>
    <div>
      <span class="legend-dot" style="background:#800080; border-color:#400040;"></span>
      Portal
    </div>
    <div>
      <span class="legend-dot" style="background:#ffa500; border-color:#cc8400;"></span>
      Outpost
    </div>
    <div>
      <span class="legend-dot" style="background:#0000ff; border-color:#000080;"></span>
      Default POI
    </div>
    <div style="margin-top:4px;">
      <span style="font-size: 16px;">—</span>
      Road
    </div>
  </div>

  <div class="export-panel">
    <label for="exportText">Last drawn road (GeoJSON Feature)</label>
    <textarea id="exportText" rows="6" spellcheck="false"
      placeholder="Use the polyline tool in the toolbar to draw a road.&#10;The resulting GeoJSON snippet will appear here."></textarea>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/leaflet-minimap/dist/Control.MiniMap.min.js"></script>

  <script>
    // Image size in pixels
    const IMG_WIDTH = 4096;
    const IMG_HEIGHT = 4096;

    // Create a Leaflet map using a simple CRS (no real-world projection)
    const map = L.map('map', {
      crs: L.CRS.Simple,
      minZoom: -2,
      maxZoom: 2
    });
    
    // Define the map bounds in "pixel coordinates": [y, x]
    const bounds = [[0, 0], [IMG_HEIGHT, IMG_WIDTH]];

    // Add the image overlay
    L.imageOverlay('map.png', bounds).addTo(map);

    // Center and zoom (you already picked a zoom level you like)
    map.setView([IMG_HEIGHT / 2, IMG_WIDTH / 2], 1); // adjust zoom as desired
    
    // --- MiniMap setup ---

    // Use a separate imageOverlay layer for the minimap
    const miniLayer = L.imageOverlay('map.png', bounds);
    
    const fixedMiniZoom = -5;  // whatever zoom you liked best
    
    const miniMap = new L.Control.MiniMap(miniLayer, {
      position: 'topleft',
      width: 150,
      height: 150,
    
      // Fixed zoom level for the minimap
      zoomLevelFixed: fixedMiniZoom,
    
      // Make the minimap use the same CRS and lock zoom,
      // and also prevent the minimap itself from being dragged/zoomed.
      mapOptions: {
        crs: L.CRS.Simple,
        minZoom: fixedMiniZoom,
        maxZoom: fixedMiniZoom,
        zoomControl: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        touchZoom: false,
        boxZoom: false,
        keyboard: false,
        dragging: false   // <-- key: minimap image no longer drags
      },
    
      // NOTE: no centerFixed here; we want the minimap to follow the main map
    
      aimingRectOptions: { weight: 1 },
      shadowRectOptions: { weight: 0, opacity: 0 },
      toggleDisplay: true
    });
    
    miniMap.addTo(map);

    // -------------------------
    //  Feature styling
    // -------------------------

    function pointToLayer(feature, latlng) {
      const kind = feature.properties && feature.properties.kind;
      let radius = 6;
      let color = '#000';
      let fillColor = '#fff';
      let options;
    
      if (kind === 'base') {
        radius = 12;
        fillColor = '#00cc00';    // bright green
        color = '#006600';        // darker green outline
        options = {
          radius,
          weight: 2,
          color,
          fillColor,
          fillOpacity: 1
        };
    
      } else if (kind === 'portal') {
        radius = 8;
        fillColor = '#800080';    // purple
        color = '#400040';
        options = {
          radius,
          weight: 2,
          color,
          fillColor,
          fillOpacity: 1
        };
    
      } else if (kind === 'outpost') {
        // New type: smaller, orange-ish
        radius = 9;
        fillColor = '#ffa500';    // orange
        color = '#cc8400';        // darker orange outline
        options = {
          radius,
          weight: 2,
          color,
          fillColor,
          fillOpacity: 1
        };
    
      } else if (kind === 'hidden') {
        // Invisible marker, used only as an anchor for labels
        options = {
          radius: 0,
          stroke: false,
          fill: false,
          opacity: 0,
          fillOpacity: 0,
          interactive: false
        };
    
      } else {
        // Default point
        fillColor = '#0000ff';
        color = '#000080';
        options = {
          radius,
          weight: 2,
          color,
          fillColor,
          fillOpacity: 1
        };
      }
    
      return L.circleMarker(latlng, options);
    }

    function style(feature) {
      const kind = feature.properties && feature.properties.kind;
      if (kind === 'road') {
        return {
          weight: 5
        };
      }
      return {};
    }

    function onEachFeature(feature, layer) {
      const props = feature.properties || {};
    
      // 1) Hidden label-only points: always visible label, no popup
      if (props.kind === 'hidden' && props.name) {
        layer.bindTooltip(props.name, {
          permanent: true,
          direction: 'right',
          offset: [8, 0],
          className: 'map-label'
        }).openTooltip();
    
        // No popup for hidden points; bail out early
        return;
      }
    
      // 2) Everything else with a name: hover label
      if (props.name) {
        layer.bindTooltip(props.name, {
          permanent: false,      // show on hover
          direction: 'top',
          offset: [0, -8],
          className: 'map-label'
        });
      }
    
      // 3) Rich popup on click (name + notes)
      if (props.name || props.notes) {
        let popup = "";
    
        if (props.name) {
          popup += `<strong>${props.name}</strong>`;
        }
        if (props.notes) {
          if (popup) popup += "<br>";
          popup += props.notes;
        }
    
        if (popup) {
          layer.bindPopup(popup);
        }
      }
    }

    // -------------------------
    //  Load existing features
    // -------------------------
    fetch('features.json')
      .then(response => response.json())
      .then(data => {
        L.geoJSON(data, {
          pointToLayer: pointToLayer,
          style: style,
          onEachFeature: onEachFeature
        }).addTo(map);
      })
      .catch(err => {
        console.error('Error loading features.json:', err);
      });

    // -------------------------
    //  Click to get pixel coordinates
    // -------------------------
    const coordsDiv = document.getElementById('coords');

    map.on('click', function(e) {
      // e.latlng.lat = y (from top), e.latlng.lng = x (from left)
      const x = Math.round(e.latlng.lng);
      const y = Math.round(e.latlng.lat);

      coordsDiv.textContent = `x: ${x}, y: ${y}`;

      // Handy snippet for creating a new base point
      const snippet = {
        type: "Feature",
        properties: {
          name: "New Place",
          kind: "base",
          notes: ""
        },
        geometry: {
          type: "Point",
          coordinates: [x, y]
        }
      };
      console.log('GeoJSON Point snippet:', JSON.stringify(snippet, null, 2));
    });

    // -------------------------
    //  Leaflet.draw setup
    // -------------------------
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    const drawControl = new L.Control.Draw({
      draw: {
        polygon: false,
        rectangle: false,
        circle: false,
        circlemarker: false,
        marker: false,
        polyline: {
          shapeOptions: {
            weight: 3
          }
        }
      },
      edit: {
        featureGroup: drawnItems,
        edit: false,
        remove: false
      }
    });

    map.addControl(drawControl);

    const exportText = document.getElementById('exportText');

    // When a new shape is created with Leaflet.draw
    map.on(L.Draw.Event.CREATED, function (e) {
      const layer = e.layer;
      drawnItems.addLayer(layer);

      // Convert to GeoJSON
      const gj = layer.toGeoJSON();

      // gj.geometry.coordinates are [lng, lat] pairs in our CRS,
      // which map directly to [x, y] pixels. We'll round them.
      const coords = gj.geometry.coordinates.map(function (c) {
        return [Math.round(c[0]), Math.round(c[1])];
      });

      // Create a ready-to-paste Feature for features.json
      const feature = {
        type: "Feature",
        properties: {
          name: "New Road",
          kind: "road",
          notes: ""
        },
        geometry: {
          type: "LineString",
          coordinates: coords
        }
      };

      const snippet = JSON.stringify(feature, null, 2);

      console.log('New road Feature:', snippet);
      if (exportText) {
        exportText.value = snippet;
      }

      alert("Road drawn! A GeoJSON Feature for it is now in the bottom-right panel and in the browser console.\n\nCopy it into features.json under \"features\".");
    });
  </script>
</body>
</html>